{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;\f2\fmodern\fcharset0 Courier-Bold;
}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\b\fs26 \cf0 \ul \ulc0 Floating point numbers:\
(
\b0 \ulnone This is 2 parts, the top is easy to understand, the 2nd is a more detailed explanation but hard to grasp
\b ).\ul \
Floating numbers - Explained easier\

\b0 \ulnone Good video to watch to get a grasp of the subject, Read notes, then watch, then read notes:\
{\field{\*\fldinst{HYPERLINK "https://www.youtube.com/watch?v=PZRI1IfStY0"}}{\fldrslt 
\b \ul https://www.youtube.com/watch?v=PZRI1IfStY0}}\
Floating Numbers, are similar to scientific notation\
\pard\pardeftab720

\fs24 \cf0 {{\NeXTGraphic unknown \width640 \height640 \noorient
}¬}\pard\pardeftab720

\fs26 \cf0 \
However instead of working in 
\b base 10
\b0  (1.10.100.1000).It works in 
\b base 2 
\b0 = 4,2,1,1/2,1/4,1/8, due to this writing certain numbers causes repetition till the max digit the computer can store (usually 23), at which point it ends and lacks the ability to round up, so it leaves a small amount from the complete total, such as 2.999.. or 3.0001.\
\

\b \ul Example in action
\b0 \ulnone \

\b Base 10 = 
\b0 100\'92s, 10\'92s, 1\'92s , 1/10 1/100, 1/1000\

\b (
\b0 hundreds, tens, one\'92s
\b )
\b0 . 
\b (
\b0 1 tenth, 1 hundredth, 1 thousandth
\b )
\b0 .\
\

\b Base 2 = 
\b0 4, 2, 1, 1/2, 1/4, 1/8, 1/16\

\b (
\b0 4\'92s, 2\'92s, 1\'92s
\b )\'a0
\b0 \'a0
\b (
\b0 halves, quarters, eighths,sixteenths
\b )
\b0 \

\b \

\b0 In 
\b Base (10)-
\b0 \'a00.1 is written as \'a00.1\
In 
\b Base (2)
\b0 \'a0
\b - 
\b0 0.1 is written as 0.00011011\

\b \
Base 10 - 
\b0 0.1
\b  = 0.1
\b0 \

\b Base 2 = 
\b0 0.1 = 
\b 0.00011
\b0 (recurring ) = 
\b 0.0001100110011
\b0 \

\b \

\b0 \'97\'a0\
In 
\b Base (10) - 
\b0 1/3 (One third) is written as:\
1\'92s \'a0- 1/10\'92s - 1/100\'92s - 1/1000\'92s (ones, tenths.. ) \'a0 \'a0 \'a0 \'a0\'a0\
\'a00 \'a0 \'a0. \'a0 \'a03 \'a0 \'a0 \'a0 \'a0 \'a0 \'a03 \'a0 \'a0 \'a0 \'a0 \'a0 \'a0 \'a03\'85\'85\'85..\
\
In 
\b Base (10) 
\b0 if a human has 1/3r + 1/3r + 1/3r = 
\b 1 (0.99999)
\b0 \
In 
\b Base(10) 
\b0 if a computer has 1/3r + 1/3r+ 1/3r =\'a0\
// It will add 0.333(till max) + 0.333(till max) +0.333(till max)= 
\b 0.99999
\b0 (till max)\
\
\
In 
\b Base(2) (robot)
\b0 - 1/10 = 0.000110011(till max digits- 
\b 23
\b0 ) \'a0+ 2/10 = 0.001100110011 (till max digits-\'a0
\b 23
\b0 ). = 1/10 + 2/10 Does not quite equal 3/10.\
\
\
This is not an issue for most things, because they do not a precision to the 23\'92rd digit. However when it comes to things like currency, where 10p + 20p (1/10 of a pound)+(2/10 of a pound), the computer outputs something like 0.300000001. Now there is an issue.\
\
To solve you would - Decimal type, store everything as integer, such as pence of cents and divide by 100 at the end.\

\b \ul \
\ulnone \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
Floating Point Numbers, detailed explanation:\ul \
\

\b0 \ulnone \
Floating-point numbers are represented in computer hardware as base 2 (binary) fractions. For example, the decimal fraction.\

\b 0.125
\b0 \
has value\'a0
\b 1/10
\b0 \'a0+\'a0
\b 2/100
\b0 \'a0+\'a0
\b 5/1000
\b0 , and in the same way the binary fraction:\

\b 0.001
\b0 \
has vaue 0/2 + 0/4 + 1/8. These two fractions have identical values, the only real difference being that the first is written in base 10 fractional notation, and the second in base 2.\'a0\
\
Unfortunately, most decimal fractions cannot be represented exactly as binary fractions. A consequence is that, in general, the decimal floating-point numbers you enter are only approximated by the binary floating-point numbers actually stored in the machine.\
\
The problem is easier to understand at first in base 10. Consider the fraction 1/3. You can approximate that as a base 10 fraction:\

\b 0.3
\b0 \
or better,\

\b 0.33
\b0 \
or, better,\'a0\

\b 0.333
\b0 \
and so on. No matter how many digits you\'92re willing to write down, the results will never be exactly 1/3, but will be an increasingly better approximation of 1/3.\'a0\
\
In the same way, no matter how many base 2 digits you\'92re willing to use, the decimal value 0.1 cannot be represented exactly as a base 2 fraction.\
\pard\pardeftab720

\f1 \cf0 0.0001100110011001100110011001100110011001100110011\
\pard\pardeftab720

\f0 \cf0 Stop at any finite number of bits, and you get an approximation.\
\
On a typical machine running Python, there are 53 bits of precision available for a Python float, so the value stored internally when you enter the decimal number\'a0
\b 0.1\'a0
\b0 is the binary fraction:\
\pard\pardeftab720

\f1 \cf0 0.00011001100110011001100110011001100110011001100110011010\
\pard\pardeftab720

\f0 \cf0 which is close to, but not exactly equal to, 1/10.\
\
It\'92s easy to forget that the stored value is an approximation to the original decimal fraction, because of the way that floats are displayed at the interpreter prompt. Python only prints a decimal approximation to the true decimal value of the binary approximation stored by the machine. If python were to print the true decimal value of the binary approximation stored for 0.1, it would have to display:\
\pard\pardeftab720

\f1 \cf0 >>> 0.1\
0.1000000000000000055511151231257827021181583404541015625\
\pard\pardeftab720

\f0 \cf0 This is more digits than most people find useful, so Python keeps the number of digits manageable by displaying a rounded value instead:\
\pard\pardeftab720

\f1 \cf0 >>> 0.1\
0.1\
\pard\pardeftab720

\f0 \cf0 It is important to realize that this is, in a real sense, an illusion: the value in the machine is not exactly 1/10, you\'92re simply rounding the display of the true machine value. This fact becomes apparent as soon as you try to do arithmetic with these values:\
\pard\pardeftab720

\f1 \cf0 >>> 0.1 + 0.2\
0.30000000000000004\
\pard\pardeftab720

\f0 \cf0 Note that this is in the very nature of binary floating-point: This is not a bug in Python, and it is not a bug in your code either. You\'92ll see the same kind of thing in all languages that support your hardware\'92s floating-point arithmetic (although some languages may not display the difference by default, or in all output modes).\
\
Other surprises follow this one. For example, if you try to round the value 2.675 to two decimal places, you get this\
\pard\pardeftab720

\f1 \cf0 >>> round(2.675, 2)\
2.67\
\pard\pardeftab720

\f2\b \cf0 (round
\f0\b0\fs32 (
\i\fs26 number
\i0 [,\'a0
\i ndigits
\i0 ]
\fs32 )
\fs26 \
\pard\pardeftab720\sa260
\cf0 Return the floating point value\'a0
\i number
\i0 \'a0rounded to\'a0
\i ndigits
\i0 \'a0digits after the decimal point. If\'a0
\i ndigits
\i0 \'a0is omitted, it defaults to zero. The result is a floating point number. Values are rounded to the closest multiple of 10 to the power minus\'a0
\i ndigits
\i0 ; if two multiples are equally close, rounding is done away from 0 (so. for example,
\f1 round(0.5)
\f0 \'a0is\'a0
\f1 1.0
\f0 \'a0and\'a0
\f1 round(-0.5)
\f0 \'a0is\'a0
\f1 -1.0
\f0 ).\
\pard\pardeftab720
\cf0 \'a0\'a0
\b )
\b0 \
\
The documentation for the built-in\'a0
\b round()\'a0
\b0 function says that it rounds to the nearest value, rounding ties away from zero. Since the decimal fraction 2.675 is exactly halfway between 2.67 and 2.68\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
}